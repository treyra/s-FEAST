"""
File containing relevant legacy code from the first draft of the paper to reproduce results as needed
"""
# pylint: skip-file

import jax.numpy as jnp

def makeAvailableActions(numAct,influenceMatrix):
    """
    Generate the actions the solvers will be allowed to consider. Uses paper first draft code

    Parameters
    ----------
    numAct : int
        The number of actuators there are
    influenceMatrix : array, shape(numState, numAct)
        B matrix

    Returns
    -------
    availableActions : array, shape(numActions,numAct)
        Array of actions that can be taken. First action is always null action

    """

    #Create list of every permutation of actions
    #Note this list is generated by converting every number from 0 to numAct^2 to binary
    availableActions = []
    #explicitly add 0 action (if optimal, we shouldn't do this, not really true if we're waiting)
    availableActions.append(jnp.zeros(numAct))
    for i in range(2**(numAct)):
        action = []
        for j in range(numAct):
            action.append(int(i/2**(j))%2)
        action = jnp.array(action)
        #Only allow 3 or fewer thrusters to fire
        if jnp.sum(action) <= 3:
            #Check if the action does anything
            if not jnp.all(jnp.matmul(influenceMatrix,action)==0):
                availableActions.append(action)


    return jnp.array(availableActions)
